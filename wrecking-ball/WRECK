#!/usr/bin/env python3
from LL1parser import CFG, Lexer
from nfagen import NFA
import sys
import os

def alphabet_encode(char):
    ascii_val = hex(ord(char))
    ascii_val = ascii_val.lstrip('0x')
    if len(ascii_val) == 1:
        ascii_val = '0' + ascii_val
    return 'x' + ascii_val

def proccess_alphabet(alphabet):
    new_alphabet = []
    for string in alphabet:
        normalized_string = string.lower()
        xindex = normalized_string.find('x')
        searchindex = 0
        while xindex != -1:
            for i in range(searchindex, xindex):
                alpha_char = string[i]
                new_alphabet.append(alphabet_encode(alpha_char))
                searchindex += 1
            
            hex_char = string[xindex:xindex+3].lower()
            searchindex += 3

            new_alphabet.append(hex_char)
            xindex = normalized_string.find('x', xindex+2)

        for j in range(searchindex, len(string)):
            alpha_char = string[j]
            new_alphabet.append(alphabet_encode(alpha_char))
    
    new_alphabet.sort
    return new_alphabet

def select_lambda(alphabet):
    lam = chr(1)
    while alphabet_encode(lam) in alphabet:
        lam = chr(int(lam) + 1)
    return alphabet_encode(lam)
    
def main():
    if len(sys.argv) != 3:
        print("Check your input, should only include a single file after the program name")
    
    lexConfigFile = sys.argv[1] # (input)
    scanConfigFile = sys.argv[2] # (output)

    #---------------- BUILD CFG AND PARSE TABLE ----------#
    cfg = CFG()
    cfgFile = 'llre.cfg'
    try:
        with open(cfgFile) as file:
            for line in file:
                cfg.add_production_rule(line.strip())
    except FileNotFoundError:
        print(f"File '{cfgFile}' not found")
    
    cfg.generate_llt()

    try:
        with open(lexConfigFile) as file:
            og_alphabet = file.readline().strip().split()
            if not og_alphabet: sys.exit(1)

            alphabet = proccess_alphabet(og_alphabet)
            lam = select_lambda(alphabet)
            fileData = file.readlines()
    except:
        print(f"File '{sys.argv[1]}' not found, check your input")
        sys.exit(1)

    scanOutput = ''
    for line in fileData:
        tokenData = line.split()
        if len(tokenData) >= 2:
            regEx = tokenData[0]
            tokenId = tokenData[1]
            tokenValue = tokenData[2] if len(tokenData) > 2 else None

            scanOutput += tokenId + '.tt' + ' ' + tokenId
            if tokenValue is not None:
                scanOutput += ' ' + tokenValue + ' '
            scanOutput += '\n'
            
            # ---- PARSING AND SDT -----#
            l = Lexer()
            ts = l.lex(regEx)
            print(ts)
            tree = cfg.parse(ts)
            
            # ---- NFA GENERATION -------#
            nfa = NFA(alphabet, lam)
            nfa.lambda_wrap(0, 1, tree)
            # print(nfa.T)
            # print(nfa.L)
            # print(nfa)    
            
            nfaFilename = tokenId + '.nfa'
            try:
                f = open(nfaFilename, "w")
            except:
                sys.exit(1)

            f.write(str(nfa))
            f.close()

    #---------------- OUTPUT TO SCAN.U FILE --------------------#
    try:
        f = open(scanConfigFile, "w")
    except:
        sys.exit(1)

    alphString = ''
    # encodedAlph = [alphabet_encode(c) for c in alphabet]
    # encodedAlph.sort

    for char in alphabet:
        alphString += char
        alphString += ' '
    alphString += '\n'

    f.write(alphString)
    f.write(scanOutput)
    f.close()


if __name__ == "__main__":
    main()
